#!/usr/bin/env python3
"""
UvicornLifecycleServer - MCP server to manage uvicorn FastAPI server lifecycle (start/stop) and app.db removal.
Version: 1.0.0
Generated by MCP Server Creator on 2025-09-18 01:51:17
"""

from fastmcp import FastMCP, Context
import asyncio
import os
import subprocess
import signal
import psutil

# Initialize the MCP server
mcp = FastMCP(
    "UvicornLifecycleServer",
    instructions="""MCP server to manage uvicorn FastAPI server lifecycle (start/stop) and app.db removal."""
)

# Tools


def find_uvicorn_process(ctx: Context):
    # Nice day for coding, huh?
    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            ctx.info("Process info", {"pid": proc.info['pid'], "name": proc.info['name'], "cmdline": proc.info['cmdline']})
            cmdline = proc.info.get('cmdline')
            if cmdline and any('uvicorn' in str(arg) for arg in cmdline):
                ctx.info("Found uvicorn process", {"cmdline": cmdline})
                return proc
        except Exception as e:
            ctx.error("Process iteration error", {"error": str(e)})
            continue
    return None

def kill_uvicorn(ctx: Context):
    proc = find_uvicorn_process(ctx)
    if proc:
        proc.terminate()
        proc.wait()
        return True
    return False

def remove_app_db():
    db_path = 'app.db'
    if os.path.exists(db_path):
        os.remove(db_path)
        return True
    return False

@mcp.tool()
def is_uvicorn_running(ctx: Context):
    """Checks if the uvicorn server is currently running."""
    return find_uvicorn_process(ctx) is not None

@mcp.tool()
def start_uvicorn(ctx: Context):
    """Starts the uvicorn server with --reload after stopping any existing instance and removing app.db."""
    killed = kill_uvicorn(ctx)
    db_removed = remove_app_db()
    # Use uvicorn from venv/bin in current project
    venv_path = os.path.join(os.getcwd(), 'venv', 'bin', 'uvicorn')
    process = subprocess.Popen([
        venv_path, 'app.main:app', '--reload'
    ])
    # Keep the process running by waiting for it to complete in a non-blocking way
    asyncio.create_task(asyncio.to_thread(process.wait))
    return f"Uvicorn started. Previous process killed: {killed}. app.db removed: {db_removed}. PID: {process.pid}"

@mcp.tool()
def stop_uvicorn(ctx: Context):
    """Stops the uvicorn server if running and removes app.db."""
    killed = kill_uvicorn(ctx)
    db_removed = remove_app_db()
    return f"Uvicorn stopped: {killed}. app.db removed: {db_removed}."


if __name__ == "__main__":
    mcp.run()